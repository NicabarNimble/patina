use super::LLMAdapter;
use anyhow::{Context, Result};
use std::fs;
use std::path::{Path, PathBuf};
use toml::Value;
use crate::brain::{Pattern, PatternType};
use crate::environment::Environment;

pub struct ClaudeAdapter;

impl LLMAdapter for ClaudeAdapter {
    fn name(&self) -> &'static str {
        "claude"
    }
    
    fn init_project(&self, project_path: &Path, design: &Value, environment: &Environment) -> Result<()> {
        // Create .claude directory structure
        let claude_path = project_path.join(".claude");
        fs::create_dir_all(&claude_path)?;
        
        // Create initial CLAUDE.md with environment info
        let claude_md_content = self.generate_initial_context(design, environment)?;
        fs::write(claude_path.join("CLAUDE.md"), claude_md_content)?;
        
        // Create MCP directory for MCP servers
        let mcp_path = claude_path.join("mcp");
        fs::create_dir_all(&mcp_path)?;
        
        // Create commands directory
        let commands_path = claude_path.join("commands");
        fs::create_dir_all(&commands_path)?;
        self.create_session_commands(&commands_path)?;
        
        // Create context/sessions directory
        let context_path = claude_path.join("context");
        fs::create_dir_all(&context_path)?;
        let sessions_path = context_path.join("sessions");
        fs::create_dir_all(&sessions_path)?;
        
        Ok(())
    }
    
    fn generate_context(
        &self,
        project_path: &Path,
        project_name: &str,
        design_content: &str,
        patterns: &[Pattern],
        environment: &Environment,
    ) -> Result<()> {
        let mut content = String::new();
        
        // Header
        content.push_str(&format!("# {} - Claude Context\n\n", project_name));
        content.push_str("This context was generated by Patina to provide comprehensive project understanding.\n\n");
        
        // Project Design
        content.push_str("## Project Design\n\n");
        content.push_str("```toml\n");
        content.push_str(design_content);
        content.push_str("\n```\n\n");
        
        // Add patterns
        self.add_patterns_to_content(&mut content, patterns);
        
        // Footer
        content.push_str("## Usage Notes\n\n");
        content.push_str("- This context provides the accumulated wisdom for this project\n");
        content.push_str("- Core patterns apply universally\n");
        content.push_str("- Topic patterns apply to specific domains\n");
        content.push_str("- Project patterns are specific to this codebase\n");
        content.push_str(&format!("\nGenerated by Patina on {}\n", chrono::Utc::now().to_rfc3339()));
        
        // Write to .claude/CLAUDE.md
        let output_path = self.get_context_file_path(project_path);
        if let Some(parent) = output_path.parent() {
            fs::create_dir_all(parent)?;
        }
        fs::write(&output_path, content)?;
        
        Ok(())
    }
    
    fn update_context(
        &self,
        project_path: &Path,
        project_name: &str,
        design: &Value,
        patterns: &[Pattern],
        environment: &Environment,
    ) -> Result<()> {
        let mut content = String::new();
        
        // Header
        content.push_str(&format!("# {} - Claude Context\n\n", project_name));
        content.push_str("This context is maintained by Patina and provides comprehensive project understanding.\n\n");
        
        // Table of Contents
        content.push_str("## Table of Contents\n\n");
        content.push_str("1. [Environment](#environment)\n");
        content.push_str("2. [Project Design](#project-design)\n");
        content.push_str("3. [Brain Patterns](#brain-patterns)\n");
        content.push_str("4. [Development Sessions](#development-sessions)\n");
        content.push_str("5. [Custom Commands](#custom-commands)\n");
        content.push_str("6. [Working Patterns](#working-patterns)\n\n");
        
        // Environment
        content.push_str(&environment.to_markdown());
        content.push_str("\n");
        
        // Project Design
        content.push_str("## Project Design\n\n");
        content.push_str(&self.format_design_toml(design));
        content.push_str("\n");
        
        // Brain Patterns
        content.push_str("## Brain Patterns\n\n");
        if patterns.is_empty() {
            content.push_str("*No patterns stored in brain yet*\n");
        } else {
            self.add_patterns_to_content(&mut content, patterns);
        }
        content.push_str("\n");
        
        // Development Sessions
        content.push_str(&self.generate_sessions_section(project_path)?);
        content.push_str("\n");
        
        // Custom Commands
        content.push_str("## Custom Commands\n\n");
        content.push_str("The following commands are available for Claude:\n\n");
        for (cmd, desc) in self.get_custom_commands() {
            content.push_str(&format!("- `{}` - {}\n", cmd, desc));
        }
        content.push_str("\nThese commands integrate with Patina's brain to capture development knowledge.\n\n");
        
        // Working Patterns
        content.push_str(&self.generate_working_patterns_section());
        
        // Footer
        content.push_str("---\n\n");
        content.push_str(&format!("*Generated by Patina on {}*\n", chrono::Utc::now().to_rfc3339()));
        content.push_str("*Run `patina update` to refresh this context*\n");
        
        // Write to file
        let output_path = self.get_context_file_path(project_path);
        fs::write(&output_path, content)?;
        
        Ok(())
    }
    
    fn get_custom_commands(&self) -> Vec<(&'static str, &'static str)> {
        vec![
            ("/project:session-start [name]", "Start a new development session"),
            ("/project:session-update [notes]", "Update current session with progress"),
            ("/project:session-end [summary]", "End session and capture learnings"),
        ]
    }
    
    fn get_context_file_path(&self, project_path: &Path) -> PathBuf {
        project_path.join(".claude").join("CLAUDE.md")
    }
}

impl ClaudeAdapter {
    fn generate_initial_context(&self, design: &Value, environment: &Environment) -> Result<String> {
        let mut content = String::from("# Claude Context\n\n");
        
        // Add creation timestamp and environment
        content.push_str(&format!("*Created: {}*\n\n", chrono::Utc::now().to_rfc3339()));
        
        // Environment overview
        content.push_str("## Environment at Creation\n\n");
        content.push_str(&format!("- **OS**: {} ({})\n", environment.os, environment.arch));
        content.push_str(&format!("- **Working Directory**: {}\n", environment.current_dir));
        
        // Available tools summary
        let available_tools: Vec<_> = environment.tools
            .iter()
            .filter(|(_, info)| info.available)
            .map(|(name, info)| {
                if let Some(version) = &info.version {
                    format!("{} ({})", name, version)
                } else {
                    name.to_string()
                }
            })
            .collect();
        
        if !available_tools.is_empty() {
            content.push_str(&format!("- **Available Tools**: {}\n", available_tools.join(", ")));
        }
        
        // Rust version and toolchain
        if let Some(rust_info) = environment.languages.get("rust") {
            if rust_info.available {
                content.push_str(&format!("- **Rust**: {}\n", rust_info.version.as_ref().unwrap_or(&"detected".to_string())));
                if let Some(toolchain) = &rust_info.toolchain {
                    content.push_str(&format!("- **Toolchain**: {}\n", toolchain));
                }
            } else {
                content.push_str("- **Rust**: ⚠️ NOT DETECTED - Required for Patina!\n");
            }
        }
        
        // Rust-specific tools
        let rust_tools: Vec<_> = environment.tools
            .iter()
            .filter(|(name, info)| name.starts_with("cargo") && info.available)
            .map(|(name, _)| name.as_str())
            .collect();
        
        if !rust_tools.is_empty() {
            content.push_str(&format!("- **Cargo Tools**: {}\n", rust_tools.join(", ")));
        }
        
        let other_languages: Vec<_> = environment.languages
            .iter()
            .filter(|(name, info)| name.as_str() != "rust" && info.available)
            .map(|(name, _)| name.as_str())
            .collect();
        
        if !other_languages.is_empty() {
            content.push_str(&format!("- **Other Languages**: {} (may need Rust bindings)\n", other_languages.join(", ")));
        }
        
        content.push_str("\n");
        
        // Extract project information
        if let Some(project) = design.get("project") {
            content.push_str("## Project\n");
            if let Some(name) = project.get("name").and_then(|v| v.as_str()) {
                content.push_str(&format!("**Name**: {}\n", name));
            }
            if let Some(purpose) = project.get("purpose").and_then(|v| v.as_str()) {
                content.push_str(&format!("**Purpose**: {}\n", purpose));
            }
            content.push('\n');
        }
        
        // Extract why section
        if let Some(why) = design.get("why") {
            content.push_str("## Why\n");
            if let Some(problem) = why.get("problem").and_then(|v| v.as_str()) {
                content.push_str(&format!("**Problem**: {}\n", problem));
            }
            if let Some(solution) = why.get("solution").and_then(|v| v.as_str()) {
                content.push_str(&format!("**Solution**: {}\n", solution));
            }
            content.push('\n');
        }
        
        // Extract technical section with validation
        if let Some(technical) = design.get("technical") {
            content.push_str("## Technical Stack\n");
            
            // Language requirement vs detected
            if let Some(language) = technical.get("language").and_then(|v| v.as_str()) {
                let lang_status = match language {
                    "rust" => if environment.languages.get("rust").map_or(false, |i| i.available) { "✓" } else { "⚠️" },
                    _ => ""
                };
                content.push_str(&format!("**Language**: {} {}\n", language, lang_status));
            }
            
            if let Some(framework) = technical.get("framework").and_then(|v| v.as_str()) {
                content.push_str(&format!("**Framework**: {}\n", framework));
            }
            
            if let Some(database) = technical.get("database").and_then(|v| v.as_str()) {
                content.push_str(&format!("**Database**: {}\n", database));
            }
            
            if let Some(constraints) = technical.get("constraints").and_then(|v| v.as_array()) {
                content.push_str("\n**Constraints**:\n");
                for constraint in constraints {
                    if let Some(c) = constraint.as_str() {
                        content.push_str(&format!("- {}\n", c));
                    }
                }
            }
            content.push('\n');
        }
        
        // Development commands if available
        if let Some(dev) = design.get("development") {
            if let Some(commands) = dev.get("commands").and_then(|v| v.as_table()) {
                content.push_str("## Development Commands\n\n");
                for (cmd, desc) in commands {
                    if let Some(s) = desc.as_str() {
                        content.push_str(&format!("- `{}`: {}\n", cmd, s));
                    }
                }
                content.push_str("\n");
            }
        }
        
        // Footer with next steps
        content.push_str("## Next Steps\n\n");
        content.push_str("1. Start a development session: `.claude/commands/session-start`\n");
        content.push_str("2. Add patterns as you work: `patina add <type> <name>`\n");
        content.push_str("3. Update context anytime: `patina update`\n");
        
        Ok(content)
    }
    
    fn create_session_commands(&self, commands_path: &Path) -> Result<()> {
        // Session start script and command
        let session_start_sh = include_str!("../../resources/claude/session-start.sh");
        let path = commands_path.join("session-start");
        fs::write(&path, session_start_sh)?;
        self.make_executable(&path)?;
        
        let session_start_md = include_str!("../../resources/claude/session-start.md");
        fs::write(commands_path.join("session-start.md"), session_start_md)?;
        
        // Session update script and command
        let session_update_sh = include_str!("../../resources/claude/session-update.sh");
        let path = commands_path.join("session-update");
        fs::write(&path, session_update_sh)?;
        self.make_executable(&path)?;
        
        let session_update_md = include_str!("../../resources/claude/session-update.md");
        fs::write(commands_path.join("session-update.md"), session_update_md)?;
        
        // Session end script and command
        let session_end_sh = include_str!("../../resources/claude/session-end.sh");
        let path = commands_path.join("session-end");
        fs::write(&path, session_end_sh)?;
        self.make_executable(&path)?;
        
        let session_end_md = include_str!("../../resources/claude/session-end.md");
        fs::write(commands_path.join("session-end.md"), session_end_md)?;
        
        Ok(())
    }
    
    #[cfg(unix)]
    fn make_executable(&self, path: &Path) -> Result<()> {
        use std::os::unix::fs::PermissionsExt;
        let mut perms = fs::metadata(path)?.permissions();
        perms.set_mode(0o755);
        fs::set_permissions(path, perms)?;
        Ok(())
    }
    
    #[cfg(not(unix))]
    fn make_executable(&self, _path: &Path) -> Result<()> {
        Ok(())
    }
    
    fn add_patterns_to_content(&self, content: &mut String, patterns: &[Pattern]) {
        // Group patterns by type
        let mut core_patterns = Vec::new();
        let mut topic_patterns: std::collections::HashMap<String, Vec<&Pattern>> = std::collections::HashMap::new();
        let mut project_patterns = Vec::new();
        
        for pattern in patterns {
            match &pattern.pattern_type {
                PatternType::Core => core_patterns.push(pattern),
                PatternType::Topic(topic) => {
                    topic_patterns.entry(topic.clone()).or_default().push(pattern);
                }
                PatternType::Project(_) => project_patterns.push(pattern),
            }
        }
        
        // Core patterns
        if !core_patterns.is_empty() {
            content.push_str("### Core Patterns\n\n");
            content.push_str("Universal principles that apply across the entire system:\n\n");
            
            for pattern in core_patterns {
                content.push_str(&format!("#### {}\n\n", pattern.name));
                content.push_str(&pattern.content);
                content.push_str("\n---\n\n");
            }
        }
        
        // Topic patterns
        if !topic_patterns.is_empty() {
            content.push_str("### Topic Patterns\n\n");
            content.push_str("Domain-specific knowledge and patterns:\n\n");
            
            for (topic, patterns) in topic_patterns {
                content.push_str(&format!("#### Topic: {}\n\n", topic));
                
                for pattern in patterns {
                    content.push_str(&format!("##### {}\n\n", pattern.name));
                    content.push_str(&pattern.content);
                    content.push_str("\n");
                }
                
                content.push_str("---\n\n");
            }
        }
        
        // Project patterns
        if !project_patterns.is_empty() {
            content.push_str("### Project-Specific Patterns\n\n");
            content.push_str("Patterns specific to this project:\n\n");
            
            for pattern in project_patterns {
                content.push_str(&format!("#### {}\n\n", pattern.name));
                content.push_str(&pattern.content);
                content.push_str("\n---\n\n");
            }
        }
    }
    
    fn format_design_toml(&self, design: &Value) -> String {
        let mut output = String::new();
        
        if let Some(project) = design.get("project").and_then(|v| v.as_table()) {
            output.push_str("### Project Information\n\n");
            for (key, value) in project {
                if let Some(s) = value.as_str() {
                    output.push_str(&format!("- **{}**: {}\n", key, s));
                }
            }
            output.push_str("\n");
        }
        
        if let Some(why) = design.get("why").and_then(|v| v.as_table()) {
            output.push_str("### Why\n\n");
            for (key, value) in why {
                if let Some(s) = value.as_str() {
                    output.push_str(&format!("**{}**: {}\n\n", key.to_uppercase(), s));
                }
            }
        }
        
        if let Some(how) = design.get("how").and_then(|v| v.as_table()) {
            output.push_str("### How\n\n");
            for (key, value) in how {
                match value {
                    Value::Array(arr) => {
                        output.push_str(&format!("**{}**:\n", key));
                        for item in arr {
                            if let Some(s) = item.as_str() {
                                output.push_str(&format!("- {}\n", s));
                            }
                        }
                        output.push_str("\n");
                    }
                    Value::String(s) => {
                        output.push_str(&format!("**{}**: {}\n\n", key, s));
                    }
                    _ => {}
                }
            }
        }
        
        if let Some(dev) = design.get("development").and_then(|v| v.as_table()) {
            output.push_str("### Development\n\n");
            
            if let Some(commands) = dev.get("commands").and_then(|v| v.as_table()) {
                output.push_str("**Commands**:\n");
                for (cmd, desc) in commands {
                    if let Some(s) = desc.as_str() {
                        output.push_str(&format!("- `{}`: {}\n", cmd, s));
                    }
                }
                output.push_str("\n");
            }
        }
        
        output
    }
    
    fn generate_sessions_section(&self, project_path: &Path) -> Result<String> {
        let mut content = String::from("## Development Sessions\n\n");
        
        let sessions_path = project_path.join(".claude").join("context").join("sessions");
        if sessions_path.exists() {
            let mut sessions = Vec::new();
            for entry in fs::read_dir(&sessions_path)? {
                let entry = entry?;
                if entry.path().extension().map_or(false, |ext| ext == "md") {
                    sessions.push(entry.path());
                }
            }
            
            // Sort by modification time (most recent first)
            sessions.sort_by_key(|p| {
                fs::metadata(p).and_then(|m| m.modified()).ok()
            });
            sessions.reverse();
            
            if sessions.is_empty() {
                content.push_str("*No development sessions recorded*\n");
            } else {
                content.push_str("Recent sessions:\n\n");
                for (i, session_path) in sessions.iter().take(5).enumerate() {
                    if let Some(filename) = session_path.file_name() {
                        content.push_str(&format!("{}. {}\n", i + 1, filename.to_string_lossy()));
                    }
                }
                content.push_str("\n");
                
                // Include content of most recent session
                if let Some(recent) = sessions.first() {
                    content.push_str("### Most Recent Session\n\n");
                    if let Ok(session_content) = fs::read_to_string(recent) {
                        content.push_str(&session_content);
                        content.push_str("\n");
                    }
                }
            }
        } else {
            content.push_str("*No sessions directory found*\n");
        }
        
        Ok(content)
    }
    
    fn generate_working_patterns_section(&self) -> String {
        let mut content = String::from("## Working Patterns\n\n");
        
        content.push_str("### Adding Knowledge\n");
        content.push_str("```bash\n");
        content.push_str("patina add <type> <name>  # Add pattern to session\n");
        content.push_str("patina commit -m \"message\"  # Commit patterns to brain\n");
        content.push_str("patina update  # Refresh this file\n");
        content.push_str("```\n\n");
        
        content.push_str("### Pattern Types\n");
        content.push_str("- `core` - Universal principles\n");
        content.push_str("- `topic` - Domain-specific knowledge\n");
        content.push_str("- `project` - Project-specific patterns\n");
        content.push_str("- `decision` - Architectural decisions\n");
        content.push_str("- `constraint` - Technical constraints\n");
        content.push_str("- `principle` - Guiding principles\n\n");
        
        content
    }
}