//! Internal implementation for Gemini adapter (stub)

use anyhow::Result;
use std::fs;
use std::path::{Path, PathBuf};
use toml::Value;

use crate::environment::Environment;
use crate::layer::{Pattern, PatternType};

/// Path constants for Gemini adapter
const ADAPTER_DIR: &str = ".gemini";
const CONTEXT_FILE: &str = "GEMINI.md";

/// Initialize Gemini project structure
pub fn init_project(project_path: &Path, design: &Value, environment: &Environment) -> Result<()> {
    // Create .gemini directory
    let gemini_path = project_path.join(ADAPTER_DIR);
    fs::create_dir_all(&gemini_path)?;
    
    // Extract project name
    let project_name = design
        .get("project")
        .and_then(|p| p.get("name"))
        .and_then(|n| n.as_str())
        .unwrap_or("project");
    
    // Generate initial context
    let content = generate_minimal_context(project_name, &[], environment);
    fs::write(gemini_path.join(CONTEXT_FILE), content)?;
    
    Ok(())
}

/// Generate context file
pub fn generate_context(
    project_path: &Path,
    project_name: &str,
    patterns: &[Pattern],
    environment: &Environment,
) -> Result<()> {
    let content = generate_minimal_context(project_name, patterns, environment);
    let output_path = get_context_file_path(project_path);
    fs::write(output_path, content)?;
    Ok(())
}

/// Update context file
pub fn update_context(
    project_path: &Path,
    project_name: &str,
    patterns: &[Pattern],
    environment: &Environment,
) -> Result<()> {
    generate_context(project_path, project_name, patterns, environment)
}

/// Get context file path
pub fn get_context_file_path(project_path: &Path) -> PathBuf {
    project_path.join(ADAPTER_DIR).join(CONTEXT_FILE)
}

/// Generate minimal context for Gemini
fn generate_minimal_context(
    project_name: &str,
    patterns: &[Pattern],
    environment: &Environment,
) -> String {
    let mut content = String::new();
    
    // Header
    content.push_str(&format!("# {project_name} - Gemini Context\n\n"));
    content.push_str("Project context for Gemini AI.\n");
    content.push_str("See root `GEMINI.md` or `README.md` for project instructions.\n\n");
    
    // Environment
    content.push_str("## Environment\n\n");
    content.push_str(&format!("- **Platform**: {} ({})\n", environment.os, environment.arch));
    content.push_str(&format!("- **Directory**: {}\n", environment.current_dir));
    
    // Available tools
    let tools = ["cargo", "git", "docker", "python"];
    let available: Vec<_> = tools
        .iter()
        .filter_map(|&tool| {
            environment.tools.get(tool)
                .filter(|info| info.available)
                .map(|_| tool)
        })
        .collect();
    
    if !available.is_empty() {
        content.push_str(&format!("- **Tools**: {}\n", available.join(", ")));
    }
    content.push('\n');
    
    // Core patterns reference
    let core_patterns: Vec<_> = patterns
        .iter()
        .filter(|p| matches!(p.pattern_type, PatternType::Core))
        .collect();
    
    if !core_patterns.is_empty() {
        content.push_str("## Patterns\n\n");
        for pattern in core_patterns {
            content.push_str(&format!("- `layer/core/{}.md`\n", pattern.name));
        }
        content.push('\n');
    }
    
    // Footer
    content.push_str(&format!(
        "---\n*Generated by Patina v{}*\n",
        env!("CARGO_PKG_VERSION")
    ));
    
    content
}