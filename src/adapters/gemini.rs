use super::LLMAdapter;
use anyhow::{Context, Result};
use std::path::{Path, PathBuf};
use std::fs;
use toml::Value;
use crate::layer::Pattern;
use crate::environment::Environment;

/// Version of the Gemini adapter
pub const GEMINI_ADAPTER_VERSION: &str = "0.1.0";

pub struct GeminiAdapter;

impl LLMAdapter for GeminiAdapter {
    fn name(&self) -> &'static str {
        "gemini"
    }
    
    fn init_project(&self, project_path: &Path, _design: &Value, _environment: &Environment) -> Result<()> {
        // Create a basic GEMINI.md in project root (like Gemini CLI expects)
        let content = r#"# Gemini Context

This project uses Patina for context management.

## Project Information

See PROJECT_DESIGN.toml for project architecture and design decisions.

## Pattern Storage

Knowledge patterns are stored in:
- `layer/core/` - Universal patterns
- `layer/topics/` - Domain patterns  
- `layer/projects/` - Project-specific patterns

---
*Generated by Patina*
"#;
        
        fs::write(project_path.join("GEMINI.md"), content)
            .context("Failed to create GEMINI.md")?;
        
        Ok(())
    }
    
    fn generate_context(
        &self,
        project_path: &Path,
        _project_name: &str,
        _design_content: &str,
        _patterns: &[Pattern],
        _environment: &Environment,
    ) -> Result<()> {
        // For now, just ensure GEMINI.md exists
        if !project_path.join("GEMINI.md").exists() {
            self.init_project(project_path, &Value::Table(Default::default()), _environment)?;
        }
        Ok(())
    }
    
    fn update_context(
        &self,
        project_path: &Path,
        _project_name: &str,
        _design: &Value,
        _patterns: &[Pattern],
        _environment: &Environment,
    ) -> Result<()> {
        // For now, just ensure GEMINI.md exists
        if !project_path.join("GEMINI.md").exists() {
            self.init_project(project_path, _design, _environment)?;
        }
        Ok(())
    }
    
    fn get_context_file_path(&self, project_path: &Path) -> PathBuf {
        project_path.join("GEMINI.md")
    }
    
    fn version(&self) -> &'static str {
        GEMINI_ADAPTER_VERSION
    }
}