package main

import (
	"context"
	"fmt"
	"os"

	"dagger.io/dagger"
)

func main() {
	ctx := context.Background()

	// Initialize Dagger client
	client, err := dagger.Connect(ctx, dagger.WithLogOutput(os.Stderr))
	if err != nil {
		panic(err)
	}
	defer client.Close()

	// Get command from args (passed by patina)
	if len(os.Args) < 2 {
		fmt.Println("Usage: go run . <command> [args...]")
		os.Exit(1)
	}

	command := os.Args[1]
	args := os.Args[2:]

	// Create base container with caching
	container := client.Container().
		From("rust:1.75").
		WithDirectory("/workspace", client.Host().Directory("."), dagger.ContainerWithDirectoryOpts{
			Exclude: []string{
				"target/",
				".git/",
				"pipelines/",
			},
		}).
		WithWorkdir("/workspace").
		WithMountedCache("/usr/local/cargo/registry", client.CacheVolume("cargo-registry")).
		WithMountedCache("/workspace/target", client.CacheVolume("cargo-target"))

	// Execute the command patina asked for
	switch command {
	case "exec":
		// Generic execution - patina decides what to run
		if len(args) == 0 {
			fmt.Println("Error: exec requires command arguments")
			os.Exit(1)
		}
		runExec(ctx, container, args)

	case "build":
		// Standard build pipeline
		runBuild(ctx, container)

	case "test":
		// Standard test pipeline
		runTest(ctx, container)

	case "container":
		// Just provide a running container
		runContainer(ctx, container)

	default:
		fmt.Printf("Unknown command: %s\n", command)
		os.Exit(1)
	}
}

// runExec runs arbitrary commands that patina requests
func runExec(ctx context.Context, container *dagger.Container, args []string) {
	fmt.Printf("ğŸ”§ Executing: %v\n", args)
	
	output, err := container.
		WithExec(args).
		Stdout(ctx)
	
	if err != nil {
		fmt.Printf("âŒ Command failed: %v\n", err)
		os.Exit(1)
	}
	
	fmt.Print(output)
}

// runBuild runs the standard build pipeline
func runBuild(ctx context.Context, container *dagger.Container) {
	fmt.Println("ğŸ”¨ Building project...")
	
	// Build release binary
	_, err := container.
		WithExec([]string{"cargo", "build", "--release"}).
		Sync(ctx)
	
	if err != nil {
		fmt.Printf("âŒ Build failed: %v\n", err)
		os.Exit(1)
	}
	
	fmt.Println("âœ… Build completed successfully")
}

// runTest runs the test suite
func runTest(ctx context.Context, container *dagger.Container) {
	fmt.Println("ğŸ§ª Running tests...")
	
	output, err := container.
		WithExec([]string{"cargo", "test", "--workspace"}).
		Stdout(ctx)
	
	if err != nil {
		fmt.Printf("âŒ Tests failed: %v\n", err)
		os.Exit(1)
	}
	
	fmt.Print(output)
	fmt.Println("âœ… All tests passed")
}

// runContainer just keeps a container running for patina to use
func runContainer(ctx context.Context, container *dagger.Container) {
	fmt.Println("ğŸ³ Container starting...")
	
	// Add git for basic operations
	container = container.
		WithExec([]string{"apt-get", "update", "-qq"}).
		WithExec([]string{"apt-get", "install", "-y", "-qq", "git"})
	
	// Signal container is ready
	_, err := container.
		WithExec([]string{"echo", "Container ready"}).
		Sync(ctx)
	
	if err != nil {
		fmt.Printf("âŒ Container failed: %v\n", err)
		os.Exit(1)
	}
	
	fmt.Println("âœ… Container ready for commands")
	// Note: Container only exists during this process
}