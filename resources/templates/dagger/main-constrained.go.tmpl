// Code generated by Patina. Modifications allowed within marked sections.
// See CONSTRAINTS.md for Go style rules.

package main

import (
    "context"
    "fmt"
    "os"
    
    "dagger.io/dagger"
)

const (
    maxFunctionLines = 50  // Patina constraint
    rustImage = "rust:1.75"
)

func main() {
    ctx := context.Background()
    
    client, err := dagger.Connect(ctx, dagger.WithLogOutput(os.Stderr))
    if err != nil {
        fmt.Fprintf(os.Stderr, "dagger connect failed: %v\n", err)
        os.Exit(1)
    }
    defer client.Close()

    if len(os.Args) < 2 {
        fmt.Println("Usage: go run . <command>")
        fmt.Println("Commands: build, test, check")
        os.Exit(1)
    }

    // Simple command dispatch - no complex routing
    var runErr error
    switch os.Args[1] {
    case "build":
        runErr = runBuild(ctx, client)
    case "test":
        runErr = runTest(ctx, client)
    case "check":
        runErr = runCheck(ctx, client)
    // === CUSTOM COMMANDS START ===
    // Add custom commands here following CONSTRAINTS.md
    // === CUSTOM COMMANDS END ===
    default:
        runErr = fmt.Errorf("unknown command: %s", os.Args[1])
    }

    if runErr != nil {
        fmt.Fprintf(os.Stderr, "Error: %v\n", runErr)
        os.Exit(1)
    }
}

// runBuild executes cargo build in container
// CONSTRAINT: Direct implementation, no abstractions
func runBuild(ctx context.Context, client *dagger.Client) error {
    fmt.Println("üî® Building project...")
    
    container := client.Container().
        From(rustImage).
        WithDirectory("/workspace", client.Host().Directory(".")).
        WithWorkdir("/workspace").
        WithMountedCache("/usr/local/cargo/registry", client.CacheVolume("cargo-registry")).
        WithMountedCache("/workspace/target", client.CacheVolume("cargo-target")).
        WithExec([]string{"cargo", "build", "--release"})
    
    _, err := container.Sync(ctx)
    if err != nil {
        return fmt.Errorf("build failed: %w", err)
    }
    
    fmt.Println("‚úÖ Build successful")
    return nil
}

// runTest executes cargo test
// CONSTRAINT: Under 50 lines, single responsibility
func runTest(ctx context.Context, client *dagger.Client) error {
    fmt.Println("üß™ Running tests...")
    
    container := client.Container().
        From(rustImage).
        WithDirectory("/workspace", client.Host().Directory(".")).
        WithWorkdir("/workspace").
        WithMountedCache("/usr/local/cargo/registry", client.CacheVolume("cargo-registry")).
        WithExec([]string{"cargo", "test", "--workspace"})
    
    output, err := container.Stdout(ctx)
    if err != nil {
        return fmt.Errorf("tests failed: %w", err)
    }
    
    fmt.Print(output)
    fmt.Println("‚úÖ All tests passed")
    return nil
}

// runCheck runs cargo clippy and fmt
func runCheck(ctx context.Context, client *dagger.Client) error {
    fmt.Println("üîç Running checks...")
    
    base := client.Container().
        From(rustImage).
        WithDirectory("/workspace", client.Host().Directory(".")).
        WithWorkdir("/workspace").
        WithMountedCache("/usr/local/cargo/registry", client.CacheVolume("cargo-registry"))
    
    // Run clippy
    _, err := base.
        WithExec([]string{"cargo", "clippy", "--", "-D", "warnings"}).
        Sync(ctx)
    if err != nil {
        return fmt.Errorf("clippy failed: %w", err)
    }
    
    // Run fmt check
    _, err = base.
        WithExec([]string{"cargo", "fmt", "--", "--check"}).
        Sync(ctx)
    if err != nil {
        return fmt.Errorf("fmt check failed: %w", err)
    }
    
    fmt.Println("‚úÖ All checks passed")
    return nil
}

// === CUSTOM FUNCTIONS START ===
// Add custom pipeline functions here
// Remember: Max 50 lines, no interfaces, direct implementation
// === CUSTOM FUNCTIONS END ===