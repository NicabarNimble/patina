package main

import (
    "context"
    "encoding/json"
    "fmt"
    "os"
    "sync"
    
    "dagger.io/dagger"
)

// ExperimentConfig is passed from Patina
type ExperimentConfig struct {
    Name     string   `json:"name"`
    Commands []string `json:"commands"`
    Port     int      `json:"port"`
}

func main() {
    ctx := context.Background()
    client, err := dagger.Connect(ctx, dagger.WithLogOutput(os.Stderr))
    if err != nil {
        panic(err)
    }
    defer client.Close()

    if len(os.Args) < 2 {
        fmt.Println("Usage: go run . <command>")
        os.Exit(1)
    }

    command := os.Args[1]

    switch command {
    case "yolo":
        runYoloExperiments(ctx, client)
    default:
        // Fall back to standard commands
        runStandardCommand(ctx, client, command, os.Args[2:])
    }
}

func runYoloExperiments(ctx context.Context, client *dagger.Client) {
    // Get experiment config from environment (set by Patina)
    configJSON := os.Getenv("PATINA_EXPERIMENTS")
    if configJSON == "" {
        // Default experiments if none specified
        configJSON = `[
            {"name": "async", "commands": ["cargo", "test", "--features", "async"], "port": 8081},
            {"name": "threads", "commands": ["cargo", "test", "--features", "threads"], "port": 8082},
            {"name": "actors", "commands": ["cargo", "test", "--features", "actors"], "port": 8083}
        ]`
    }

    var experiments []ExperimentConfig
    if err := json.Unmarshal([]byte(configJSON), &experiments); err != nil {
        panic(fmt.Sprintf("Failed to parse experiments: %v", err))
    }

    // Base container setup
    base := client.Container().
        From("rust:latest").
        WithDirectory("/workspace", client.Host().Directory(os.Getenv("PATINA_PROJECT_ROOT"))).
        WithWorkdir("/workspace").
        WithMountedCache("/usr/local/cargo/registry", client.CacheVolume("cargo-registry")).
        WithMountedCache("/workspace/target", client.CacheVolume("cargo-target"))

    // Launch experiments in parallel
    var wg sync.WaitGroup
    results := make(chan string, len(experiments))

    for _, exp := range experiments {
        wg.Add(1)
        go func(experiment ExperimentConfig) {
            defer wg.Done()
            
            fmt.Printf("ðŸ§ª Starting experiment: %s\n", experiment.Name)
            
            // Create experiment container
            container := base.
                WithEnvVariable("EXPERIMENT_NAME", experiment.Name).
                WithExec([]string{"sh", "-c", "echo 'Experiment " + experiment.Name + " starting...'"})
            
            // Run the experiment commands
            for _, cmd := range experiment.Commands {
                container = container.WithExec([]string{"sh", "-c", cmd})
            }
            
            // Capture output
            output, err := container.
                WithExec([]string{"sh", "-c", "echo 'EXPERIMENT_COMPLETE: " + experiment.Name + "'"}).
                Stdout(ctx)
            
            if err != nil {
                results <- fmt.Sprintf("âŒ Experiment %s failed: %v", experiment.Name, err)
            } else {
                results <- fmt.Sprintf("âœ… Experiment %s completed\n%s", experiment.Name, output)
            }
        }(exp)
    }

    // Wait for all experiments
    wg.Wait()
    close(results)

    // Report results
    fmt.Println("\nðŸ“Š Experiment Results:")
    for result := range results {
        fmt.Println(result)
        fmt.Println("---")
    }
}

func runStandardCommand(ctx context.Context, client *dagger.Client, command string, args []string) {
    // Standard single-container commands (build, test, etc)
    container := client.Container().
        From("rust:latest").
        WithDirectory("/workspace", client.Host().Directory(".")).
        WithWorkdir("/workspace")

    switch command {
    case "build":
        _, err := container.WithExec([]string{"cargo", "build", "--release"}).Sync(ctx)
        if err != nil {
            fmt.Printf("âŒ Build failed: %v\n", err)
            os.Exit(1)
        }
        fmt.Println("âœ… Build completed")
    case "test":
        _, err := container.WithExec([]string{"cargo", "test"}).Sync(ctx)
        if err != nil {
            fmt.Printf("âŒ Tests failed: %v\n", err)
            os.Exit(1)
        }
        fmt.Println("âœ… Tests passed")
    }
}