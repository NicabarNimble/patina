# Session: spec-feedback-loop.md review before build
**ID**: 20251217-100538
**Started**: 2025-12-17T15:05:38Z
**LLM**: claude
**Git Branch**: patina
**Session Tag**: session-20251217-100538-start
**Starting Commit**: d04c51366cb6df55ef514df4b9c22883fdd6cf3c

## Previous Session Context
Last session reviewed Meta's REFRAG paper against Patina's feedback loop design. Key validation: REFRAG's block-diagonal attention patterns (retrieved passages are semantically independent) support our utility-based prioritization - high-utility files deserve full context, low-utility can be compressed. Identified potential enhancements: variable-depth retrieval by utility (full/summary/minimal presentation based on hit_rate), and utility-based presentation policy. Combined with prior CLaRa review, both external papers validate our core principle: downstream task completion (commits) as supervision signal for retrieval quality.

## Goals
- [x] spec-feedback-loop.md review before build
- [x] Exhaustive RL/ML review of feedback loop design
- [x] Design better build tracking system
- [x] Create spec-build-system.md
- [x] Update build.md with Phase 4

## Activity Log
### 10:05 - Session Start
Session initialized with goal: spec-feedback-loop.md review before build
Working on branch: patina
Tagged as: session-20251217-100538-start

### 10:15 - Context Gathering
- Anchored in layer/core values (dependable-rust, unix-philosophy, adapter-pattern)
- Read spec-feedback-loop.md thoroughly
- Reviewed current git workflow (conventional commits, session tags, spec tags)
- Examined trainer.rs (found broken gradient computation - constant loss root cause)
- Reviewed scry/mod.rs, eval/mod.rs, scrape/database.rs

### 10:30 - RL/ML PhD Review of Feedback Loop Spec

**Exhaustive analysis through Andrew Ng / RL lens:**

| Aspect | Assessment |
|--------|------------|
| Problem formulation | ✅ Correct - logged bandit, not full RL |
| Reward signal | ✅ Commits as ground truth is right |
| Credit assignment | ⚠️ Session-level attribution is coarse but MVP-appropriate |
| Metrics design | ✅ Precision@k by rank is key metric |
| Stability×Utility model | ✅ Novel departure from time-decay |
| Sample efficiency | ✅ Measurement-first approach correct for data volume |
| Trainer diagnosis | ✅ Correctly identified broken gradients (constant 0.001 for layer 1) |
| Scope control | ✅ Correctly defers learning to future phase |

**Key insights validated:**
- Spec correctly frames as logged bandit feedback (not online RL)
- `stability × utility = relevance` is a novel and well-motivated model
- Defers learning until measurement proves signal exists

**Recommendations before build:**
- Add path normalization to feedback SQL views
- Document counterfactual limitation explicitly
- Consider structured session_id storage (not just parsed from markdown)

### 11:00 - Build System Discussion: GitHub Issues

**Initial proposal:** Use GitHub Issues as source of truth for deferred work.

**Discovery:** GitHub Issues are repo-scoped, NOT branch-scoped.
- Issues exist globally across all branches
- Can't have "branch-local" issues
- For repos we don't own (e.g., rust-lang/rust), can't create Patina issues

**Verdict:** Deal killer for our use case. Need alternative.

### 11:30 - Exploring Alternatives

**Evaluated options:**
1. **Commit trailers** - Git-native, branch-local, parseable
2. **Git notes** - Obscure, not shown in GitHub UI
3. **Layer files** - More files to manage
4. **Mothership storage** - Not version controlled
5. **Orphan branch** - Over-engineered
6. **In-repo TOML** - Simple, structured, git-tracked

**Two problems identified:**
1. **Branch sharing** (how do Patina users share context on repos they can't push to) - DEFERRED to future multi-user phase
2. **Build tracking** (how to track tasks, deferred work, explorations) - FOCUS of this session

### 12:00 - Going Too Deep (Meta-Learning)

**Rabbit hole:** Designed complex system where:
- Build commands instrumented to eventlog
- Outcomes tracked (reopen rate, completion rate)
- Patterns analyzed to learn when each command succeeds
- Guidance updated based on learnings
- "Patina learns how to teach LLMs to use Patina"

**Problem:** Got way too meta and complicated.

### 12:15 - Zoom Out (Andrew Ng / Eskil Check)

**Andrew Ng would say:**
> "Do you have any data yet? No? Then why design ML infrastructure for something that doesn't exist?"

**Eskil Steenberg would say:**
> "What does this DO? One sentence."

**Reality check:**
- We designed a meta-learning system for a tool that doesn't exist
- We have zero data on how LLMs use `patina build`
- Violated core principles: dependable-rust (no small interface), unix-philosophy (not one job)

**Course correction:** Build the simple thing first.

### 12:30 - Final Design: Hybrid TOML + Commit Trailers

**Architecture:**
```
.patina/build.toml          ← Current state (queryable, structured)
patina build commands       ← Update state + auto-commit with trailers
Git log                     ← Audit trail (free from git)
CLAUDE.md                   ← Teaches LLM when to use what
```

**State file schema:**
- `[[phase]]` - phases with status
- `[[task]]` - tasks with id, title, status (pending/active/complete/abandoned)
- `[[deferred]]` - deferred work with reason, target phase
- `[[exploration]]` - rabbit holes with status, learned outcome

**Commands (10 total):**
```bash
# Query
patina build status
patina build tasks
patina build deferred
patina build explorations

# Tasks
patina build task start <id>
patina build task done <id>
patina build task abandon <id> --reason "..."

# Deferred
patina build defer "<title>" --reason "..."
patina build undefer <id>

# Explorations (rabbit holes)
patina build explore "<title>"
patina build explore done [--learned "..."]
patina build explore abandon --learned "..."
```

**Commit trailers:**
```
build(task): complete 3a - Instrument Scry

Task: 3a
Task-Status: complete
Phase: 3
```

**LLM learns via:**
- CLAUDE.md section explaining when to use each command
- Session start shows build status (primes context)
- Rule of thumb: TodoWrite = tactical/ephemeral, patina build = strategic/persistent

**Exploration tracking (rabbit holes):**
- `explore` starts tracking
- `explore done --learned` captures success
- `explore abandon --learned` captures dead end but preserves learnings
- Key: Always capture `--learned` - even failures produce knowledge

### 13:00 - Spec and Build.md Updates

**Created:** `layer/surface/build/spec-build-system.md`
- Full specification for Phase 4
- TOML schema with examples
- All commands documented
- Commit trailer format
- LLM integration via CLAUDE.md
- ~400 lines of Rust estimated

**Updated:** `layer/core/build.md`
- Added spec-build-system.md to active specs
- Added Phase 4: Build Tracking System
- 6 tasks (4a-4f) with validation criteria

## Key Decisions

1. **GitHub Issues not for Patina tracking** - They're repo-global, we need branch-local
2. **Branch sharing deferred** - Future multi-user problem, not needed for solo use
3. **TOML + trailers hybrid** - Simple, git-native, queryable
4. **Explorations are first-class** - Rabbit holes tracked with mandatory learnings
5. **LLM guidance via docs** - CLAUDE.md teaches usage, no meta-learning needed
6. **Simplicity over cleverness** - Build it, use it, add complexity only if needed

## Key Insights

1. **Feedback loop spec is solid** - RL/ML review validates the design, ready to build
2. **GitHub Issues are repo-scoped** - Fundamental limitation discovered
3. **Commit trailers are underused** - Git-native structured metadata, branch-local
4. **Meta-learning is premature** - Can't optimize what doesn't exist yet
5. **Explorations need tracking** - Rabbit holes are valuable even when they fail

## Files Created/Modified

| File | Change |
|------|--------|
| `layer/surface/build/spec-build-system.md` | NEW - Full Phase 4 spec |
| `layer/core/build.md` | Updated - Added Phase 4 |
| `.claude/context/active-session.md` | Updated - This file |

## Open Questions

1. Should `patina build` auto-commit, or stage and let user commit?
2. Should session-start automatically run `patina build status`?
3. How to handle migration from current build.md to build.toml?

## Next Steps

1. Complete Phase 3 (Feedback Loop) implementation
2. Then Phase 4 (Build System) implementation
3. Use Phase 4 tooling to track Phase 5+ work


### 12:35 - Update (covering since 10:05)

**Git Activity:**
- Commits this session: 0
- Files changed: 4
- Last commit: 4 hours ago

**Work Completed:**
- Exhaustive RL/ML review of spec-feedback-loop.md (logged bandit framing validated)
- Deep exploration of GitHub Issues as tracking mechanism (discovered repo-scope limitation)
- Evaluated 6 alternatives: commit trailers, git notes, layer files, mothership, orphan branch, TOML
- Separated two problems: branch sharing (deferred) vs build tracking (focused)
- Went down meta-learning rabbit hole, course-corrected with Andrew Ng / Eskil perspective
- Designed hybrid TOML + commit trailers system with exploration tracking
- Created `layer/surface/build/spec-build-system.md` (Phase 4 full spec)
- Updated `layer/core/build.md` with Phase 4 tasks and validation criteria
- Wrote comprehensive session documentation in active-session.md

**Discussion Context:**
- Started with "review spec before build" goal
- User pushed for RL/ML PhD-level analysis of feedback loop design
- GitHub Issues discussion revealed fundamental architectural constraint (repo-scoped)
- User identified need to track rabbit holes/explorations explicitly
- "What would Andrew Ng say?" became the simplicity check
- User wanted to ensure LLM frontends (Claude Code, Gemini CLI) can drive the system

**Key Decisions:**
1. GitHub Issues rejected for Patina tracking (repo-global vs branch-local need)
2. Branch sharing deferred to future multi-user phase
3. TOML state file + commit trailers + CLAUDE.md guidance = the simple solution
4. Explorations are first-class citizens with mandatory `--learned` capture
5. No meta-learning infrastructure - build simple thing first, add complexity if needed
6. ~10 commands total, ~400 lines of Rust estimated

**Challenges Faced:**
- Got too deep into meta-learning design ("Patina learns to teach LLMs to use Patina")
- Violated own core principles (dependable-rust, unix-philosophy) in over-engineering
- Had to zoom out multiple times to stay grounded

**Patterns Observed:**
- "Can I explain this in one sentence?" is the ultimate simplicity test
- Commit trailers are underutilized git-native structured metadata
- Separating problems (branch sharing vs build tracking) unlocked progress
- Rabbit holes need explicit tracking - even failed explorations produce knowledge
- Teaching LLMs is documentation + context injection, not complex ML (for now)


## Session Classification
- Work Type: exploration
- Files Changed:        0
- Commits:        0
- Patterns Modified:        0
- Session Tags: session-20251217-100538-start..session-20251217-100538-end
