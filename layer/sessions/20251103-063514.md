# Session: sqlite-usearch-vectors
**ID**: 20251103-063514
**Started**: 2025-11-03T11:35:14Z
**LLM**: claude
**Git Branch**: neuro-symbolic-knowledge-system
**Session Tag**: session-20251103-063514-start
**Starting Commit**: 07e10ef2ea9e87ccd5e44e1f7b87e52c1c36bd66

## Previous Session Context
Previous session pivoted architecture from Turso dual API strategy to SQLite + USearch hybrid storage for local-first vector search. Abandoned async containment complexity in favor of 100% sync codebase using USearch (10x faster than FAISS, <1MB footprint, memory-mapped indices). Created comprehensive design document `layer/surface/sqlite-usearch-vectors.md` and archived Turso exploration. Key decision: direct library usage over abstraction layers - DatabaseBackend enum is obsolete.

## Goals
- [ ] sqlite-usearch-vectors

## Activity Log
### 06:35 - Session Start
Session initialized with goal: sqlite-usearch-vectors
Working on branch: neuro-symbolic-knowledge-system
Tagged as: session-20251103-063514-start


### 11:09 - Update (covering since 06:35)

**Git Activity:**
- Commits this session:       13
- Files changed: 1
- Last commit: 9 minutes ago

**Work Completed:**
- ✅ Phase 1: Removed DatabaseBackend enum (9 commits)
  - Deleted `src/db/backend.rs` and `src/db/config.rs`
  - Updated SemanticSearch, EmbeddingsDatabase, scrape Database to use SqliteDatabase directly
  - Updated examples and tests
  - All 46 tests passing
- ✅ Phase 2: Implemented BeliefStorage with SQLite + USearch (3 commits)
  - Created `src/storage/` module (mod.rs, types.rs, beliefs.rs)
  - Dual storage: SQLite for metadata, USearch for vector ANN search
  - rowid-based key strategy solves UUID→u64 truncation
  - Memory-mapped indices with zero-copy loading
  - 4 comprehensive tests (creation, roundtrip, ranking, direct USearch)
- ✅ RETURNING clause refactor
  - Replaced `execute() + last_insert_rowid()` with atomic `INSERT ... RETURNING rowid`
  - Removed `OR REPLACE` (beliefs now immutable, insert-only)
  - Prevents index corruption from orphaned keys
- ✅ Updated design document to reflect implementation reality
  - Status: design → active
  - Documented Phase 1-2 completion with discoveries
  - Updated code examples to match actual implementation

**Key Decisions:**
- **rowid as USearch key**: Use SQLite's auto-incrementing rowid instead of UUID
  - Rationale: UUID→u64 cast truncates data, rowid is stable i64
  - Pattern validated by Memista reference implementation
- **Sync-only architecture**: No async, no tokio (deliberate for CLI use case)
  - Rationale: Local-first tool, single-threaded workflows, simpler for LLM-assisted development
- **Immutable beliefs**: Insert-only, no upsert
  - Rationale: Event sourcing philosophy, prevents index corruption
  - Fail fast on duplicate UUID vs silent corruption
- **RETURNING clause**: Atomic insert with rowid retrieval
  - Rationale: More atomic than separate statements, clearer intent, safer
  - Future-proof for potential batch operations

**Challenges Faced:**
1. **UUID truncation issue**: Initial attempt used `UUID.as_u128() as u64` which lost data
   - Solution: Use rowid as USearch key, keep UUID for external identity
2. **USearch index segfault**: Adding vectors without `reserve()` caused crashes
   - Solution: Call `index.reserve(1000)` at initialization
3. **Test failures with vector search**: Empty results due to mismatched key types
   - Solution: Consistent rowid→u64 casting throughout search/hydration flow
4. **OR REPLACE causing orphaned keys**: REPLACE deletes old row (new rowid), orphaning USearch entry
   - Solution: Remove OR REPLACE, make beliefs immutable (insert-only)

**Patterns Observed:**
- **Memista validation**: Reference implementation confirmed our rowid strategy and dual storage pattern
- **Scalpel commits**: 13 focused commits (avg 1 purpose each) maintained clean history
- **Test-driven refinement**: Tests revealed edge cases (segfault, orphaned keys) before production use
- **Design-code alignment**: Updated design doc after implementation captures reality vs speculation
- **Rust's type safety extends to storage**: "Make invalid states unrepresentable" - duplicate UUIDs error instead of corrupt


## Session Classification
- Work Type: pattern-work
- Files Changed:       14
- Commits:       13
- Patterns Modified:        1
- Session Tags: session-20251103-063514-start..session-20251103-063514-end
