# Session: Adding Bitwarden to secrets-boundary
**ID**: 20251224-071100
**Started**: 2025-12-24T12:11:00Z
**LLM**: claude
**Git Branch**: patina
**Session Tag**: session-20251224-071100-start
**Starting Commit**: 251da91faa99a8667b4196c714d2910a4ffed8c2

## Previous Session Context
Implemented complete `patina secrets` command family (init, add, run, status) with 1Password backend - 7 commits covering core module, CLI commands, and MCP gate. Testing revealed critical 1Password limitations: per-terminal Touch ID prompts, no container/CI support, and service accounts are read-only (can't create vaults/items). Research showed Bitwarden's session token model (`BW_SESSION`) solves all these issues with long-lived tokens that have full permissions. Open question: pivot to Bitwarden or support both backends.

## Goals
- [x] Research Bitwarden as 1Password alternative
- [x] Design FOSS local vault solution (pivoted from Bitwarden)
- [x] Document spec-secrets-v2.md
- [x] Archive completed specs (cleanup)
- [ ] Address spec gaps (session cache, docker injection)
- [ ] Implementation

## Activity Log
### 07:11 - Session Start
Session initialized with goal: Adding Bitwarden to secrets-boundary
Working on branch: patina
Tagged as: session-20251224-071100-start

### 11:31 - Update (covering since 07:11)

**Git Activity:**
- Commits this session: 2
- Files changed: 7
- Last commit: 8 minutes ago

**Work Completed:**
- Researched Bitwarden CLI (`bw`) - discovered account requirement
- Discovered Bitwarden Secrets Manager (`bws`) has `bws run` like `op run`
- Pivoted away from both Bitwarden products (SaaS dependency)
- Designed fully FOSS local vault using age encryption + macOS Keychain
- Consulted with second LLM for design review (valuable feedback on session caching, Touch ID frequency, multi-recipient)
- Created `spec-secrets-v2.md` with full design
- Archived 7 completed specs to git tags, deleted files (15 → 9 specs)
- Updated `build.md` with new direction

**Key Decisions:**
1. **Rejected Bitwarden** - Still requires cloud account, against FOSS principles
2. **Local vault with age** - Proven encryption (FiloSottile), pure Rust (`rage` crate)
3. **macOS Keychain for identity** - Touch ID UX, iCloud sync, no password to remember
4. **Session caching** - Avoid repeated Touch ID (identified as gap to resolve)
5. **Recipient separation** - Store public key in plaintext, only decrypt needs Touch ID
6. **Minimal command surface** - 2 subcommands + flags, not subcommand sprawl
7. **Auto-init on first add** - No explicit `init` command needed

**Design Insights (from second LLM review):**
- Touch ID prompt frequency is critical - need session cache
- Encrypt doesn't need identity (use stored recipient)
- Multi-recipient support for future-proofing
- iCloud Keychain sync is convenience, not guarantee - need export/import
- Threat model same as 1Password - don't overclaim

**Spec Gaps Identified:**
1. Session cache persistence - "no daemon" but process is short-lived
2. Add triggers Touch ID (must decrypt to re-encrypt)
3. Docker injection mechanism not specified

**Patterns Observed:**
- Consulting second LLM for design review caught real issues
- "Trust boundary" framing clarified the design (Mac = trust boundary)
- Archive pattern: git tag + delete file, not just mark as archived

---

## Open Items for Next Session

### Spec Gaps to Resolve

**1. Session Cache Persistence**
- Problem: Spec says "in-memory TTL, no daemon" but `patina secrets run` is a short-lived process
- Each invocation is a new process - can't share in-memory state
- Options to evaluate:
  - A) Encrypted cache file with short TTL (e.g., `~/.patina/.session.age`)
  - B) Unix socket daemon (we said no daemons, but reconsider?)
  - C) Accept Touch ID per `run` call (defeats purpose of session cache)
  - D) macOS Keychain can cache unlock state briefly (research this)

**2. Add Triggers Touch ID**
- Problem: Adding a secret requires decrypt → modify → re-encrypt
- Must read existing vault to append new secret
- Only the very first secret (init) avoids Touch ID
- Acceptable? Or find workaround?

**3. Docker Injection Mechanism**
- Problem: Spec says "Mac injects, container receives" but doesn't specify how
- Options:
  - `docker run -e VAR=val ...` (new container)
  - `docker exec -e VAR=val container ...` (running container)
  - `patina secrets run -- docker run ...` (patina wraps docker)
- Need to document the supported patterns

### Implementation Order (Suggested)
1. Resolve spec gaps above
2. Add dependencies (`age`, `security-framework`)
3. Implement `vault.rs` (age encrypt/decrypt)
4. Implement `keychain.rs` (macOS Keychain access)
5. Implement `session.rs` (cache, once design decided)
6. Update `mod.rs` public API
7. Update `commands/secrets.rs` CLI
8. Delete `internal.rs` (1Password code)
9. Test full flow
10. Update MCP gate if needed

### Files to Reference
- Spec: `layer/surface/build/spec-secrets-v2.md`
- Current impl: `src/secrets/mod.rs`, `src/secrets/internal.rs`
- CLI: `src/commands/secrets.rs`
- Archived 1Password spec: `git show spec/secrets-1password:layer/surface/build/spec-secrets-boundary.md`


### 12:10 - Update (covering since 11:31)

**Git Activity:**
- Commits this session: 0
- Files changed: 7
- Last commit: 47 minutes ago

**Work Completed:**
- Compared v1 (1Password) vs v2 (Local Vault) in detail
- Documented what we lose (1Password GUI, audit trail, `--item`/`--field`)
- Documented what we gain (containers, CI/CD, session cache, FOSS, no account)
- Identified 3 spec gaps requiring resolution before implementation
- Added detailed "Open Items for Next Session" section with options and implementation order

**Session Wrap-up:**
- Spec v2 design complete, gaps documented
- Ready for implementation in next session


## Session Classification
- Work Type: pattern-work
- Files Changed:        9
- Commits:        2
- Patterns Modified:        9
- Session Tags: session-20251224-071100-start..session-20251224-071100-end
