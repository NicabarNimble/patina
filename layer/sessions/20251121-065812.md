# Session: review build.md and spec files
**ID**: 20251121-065812
**Started**: 2025-11-21T11:58:12Z
**LLM**: claude
**Git Branch**: neuro-symbolic-knowledge-system
**Session Tag**: session-20251121-065812-start
**Starting Commit**: e752e78cdbf4462e2ba7934cb682fdeebb3c4882

## Previous Session Context
Previous session created the build recipe system (`layer/core/build.md`) with a 5-phase roadmap and 5 detailed spec documents in `layer/surface/` covering event foundation, mothership service, persona capture, progressive adapters, and cross-project features. Key architectural decisions: REST (axum) over gRPC for mothership, YAML registry format at `~/.patina/projects.registry`, and separation of specs (surface) from recipe (core).

## Goals
- [ ] review build.md and spec files

## Activity Log
### 06:58 - Session Start
Session initialized with goal: review build.md and spec files
Working on branch: neuro-symbolic-knowledge-system
Tagged as: session-20251121-065812-start

### ~10:00 - Multi-User Architecture Locked In

**Setup:**
```
USER A's Mac                              USER B's Mac
─────────────────────────────────────     ─────────────────────────────────────

~/.patina/                                ~/.patina/
├── projects.registry                     ├── projects.registry
│   └── livestore: ~/repos/livestore      │   └── livestore: ~/repos/livestore
├── persona/                              ├── persona/
│   ├── events/     ← A's beliefs         │   ├── events/     ← B's beliefs
│   └── beliefs.db                        │   └── beliefs.db
└── config.toml                           └── config.toml

~/repos/livestore/                        ~/repos/livestore/
├── .patina/                              ├── .patina/
│   ├── events/        ← SHARED (git)     │   ├── events/        ← SHARED (git)
│   │   ├── *.json                        │   │   ├── *.json
│   │   └── manifest.json                 │   │   └── manifest.json
│   ├── adapters/      ← SHARED (git)     │   ├── adapters/      ← SHARED (git)
│   │   └── e5-base-v2/                   │   │   └── e5-base-v2/
│   │       ├── semantic.onnx             │   │       ├── semantic.onnx
│   │       └── temporal.onnx             │   │       └── temporal.onnx
│   └── data/          ← LOCAL (rebuild)  │   └── data/          ← LOCAL (rebuild)
│       ├── patina.db                     │       ├── patina.db
│       └── *.usearch                     │       └── *.usearch
└── src/                                  └── src/
```

**Event Flow (Multi-User):**
```
User A works on livestore:
─────────────────────────
/session-start "add error handling"
/session-note "TypeScript prefers Result types here"
    → .patina/events/2025-11-21-042-observation-captured.json
git commit & push

User B pulls:
─────────────
git pull  (gets new events + any adapter updates)
patina materialize  (rebuilds local patina.db)
patina oxidize      (rebuilds local vectors)
    → Now has A's observation in their searchable index

User B works:
─────────────
/session-note "Effect library handles this elegantly"
    → .patina/events/2025-11-21-043-observation-captured.json
git commit & push

Both users now share both observations.
```

**Persona (NOT Shared):**
```
User A's persona (~/.patina/persona/):
├── "I prefer Rust Result<T,E> over exceptions"
├── "ECS is better for games"
└── "Always use explicit error types"

User B's persona (~/.patina/persona/):
├── "Effect-TS is the way"
├── "Functional core, imperative shell"
└── "TypeScript > JavaScript always"

These are PERSONAL beliefs, not project knowledge.
Different developers, different perspectives.
```

**Scry Query Flow:**
```
User A: patina scry "error handling patterns"
────────────────────────────────────────────

1. Query project (livestore/.patina/data/)
   ├── Vector search: finds observations
   ├── SQLite: gets context, code refs
   └── Results: [PROJECT] "TypeScript prefers Result types"
                [PROJECT] "Effect library handles this"

2. Query persona (~/.patina/persona/)
   └── Results: [PERSONA] "I prefer Rust Result<T,E>"
                [PERSONA] "Always use explicit error types"

3. Combine & present to LLM:
   ┌─────────────────────────────────────────────┐
   │ PROJECT KNOWLEDGE (from livestore):         │
   │ • TypeScript prefers Result types here      │
   │ • Effect library handles this elegantly     │
   │                                             │
   │ YOUR BELIEFS (from persona):                │
   │ • You prefer Rust Result<T,E>               │
   │ • You like explicit error types             │
   │                                             │
   │ Note: Your Rust preferences may inform      │
   │ TypeScript patterns here.                   │
   └─────────────────────────────────────────────┘
```

**Mothership's Role:**
```
patina serve (running on each Mac)
─────────────────────────────────

Endpoints:
  POST /embed         ← generates embeddings (E5)
  POST /scry          ← unified query across project + persona
  GET  /projects      ← list registered projects
  POST /materialize   ← trigger rebuild for a project

NOT doing:
  ✗ Watching for changes
  ✗ Aggregating events across users
  ✗ Syncing (git does that)
```

**The Key Separations:**

| What | Where | Shared? |
|------|-------|---------|
| Events (facts) | project/.patina/events/ | Yes (git) |
| Adapters (weights) | project/.patina/adapters/ | Yes (git) |
| Materialized db | project/.patina/data/ | No (rebuild) |
| Vectors | project/.patina/data/ | No (rebuild) |
| Persona | ~/.patina/persona/ | No (personal) |
| Mothership | ~/.patina/ | No (local daemon) |

Git syncs knowledge. Each user materializes locally. Personas stay personal.

### ~10:30 - Multi-User Adapter Sharing: Recipe Model

**Key Insight:** Share recipes, not artifacts. Like Cargo.toml → target/.

**Shared (git-tracked):**
```yaml
# .patina/oxidize.yaml (recipe)
embedding_model: e5-base-v2

projections:
  semantic:
    type: dimension
    layers: [768, 1024, 256]
    training:
      source: sessions.observations
      epochs: 10

  temporal:
    type: dimension
    layers: [768, 1024, 256]
    training:
      source: git.co_changes
      epochs: 10

  state-encoder:
    type: world-model
    layers: [768, 1024, 512]
    training:
      source: git.transitions
      epochs: 20
```

**Local (gitignored, built from recipe):**
```
.patina/data/
└── embeddings/e5-base-v2/
    └── projections/
        ├── semantic.onnx     ← built locally
        └── temporal.onnx     ← built locally
```

**Workflow:**
```bash
git pull                    # get latest events + recipe
patina materialize          # events → SQLite
patina oxidize              # recipe + SQLite → adapters + vectors
```

**Growth Path:**
```
TODAY                    NEAR-TERM                FAR-FUTURE
──────────────────────   ──────────────────────   ──────────────────────
Recipe in git            Recipe + version check   Recipe + P2P cache
Build locally            "Do we match?"           "Who has this built?"
Trust the recipe         Verify hashes            Share artifacts
```

**Future Persona Network (north star, not v1):**
- CRDT-based persona sync (beyond git)
- P2P belief exchange between personas
- Agent-to-agent queries
- Decentralized knowledge network
- Architecture should not preclude this


### 11:26 - Update (covering since 06:58)

**Git Activity:**
- Commits this session: 0
- Files changed: 11
- Last commit: 5 hours ago

**Work Completed:**

1. **Spec Review & Divergence Analysis**
   - Identified 8 divergences between specs and prior session decisions
   - Fixed: port 50051 (keep it), dimension math (~2,000), TOML→YAML, event naming, 2-layer MLP

2. **Major Architecture Evolution**
   - Rejected real-time event emission → adopted "scrape existing logs" model
   - Git, sessions, code ARE logs - no need to emit events in real-time
   - New pipeline: `scrape → events → materialize → SQLite → oxidize → vectors`

3. **Adapter Architecture Clarified**
   - Three families: foundational (LLMs), embeddings (frozen), projections (learned)
   - Recipe model: share `oxidize.yaml`, build locally (like Cargo.toml → target/)
   - Projections are children of embeddings (change embedding → retrain all)

4. **Multi-User Architecture Designed**
   - Events + recipe git-tracked, data gitignored
   - Personas personal (never shared), project knowledge shared
   - Documented User A/B walkthrough for livestore scenario

5. **Specs Aligned with New Vision**
   - Rewrote `build.md` - 6 phases with architecture summary
   - Created `spec-scrape-pipeline.md`, `spec-oxidize.md`
   - Updated mothership (added scry), persona, cross-project specs
   - Removed obsolete `spec-event-foundation.md`

**Key Decisions:**

1. **Scrape not emit** - Read existing logs instead of instrumenting shell scripts
2. **Recipe model** - Share training config, build artifacts locally
3. **Scry unifies queries** - Project + persona in one command
4. **Personas never shared** - Personal beliefs stay machine-local
5. **Future: CRDT persona network** - North star, architecture shouldn't preclude

**Patterns Observed:**

- LiveStore event model good for sync, but we're git-native (different constraints)
- "Log builder not watcher" insight simplified entire architecture
- Small adapters (~4MB) can be git-tracked OR recipe-built - flexibility
- Clear separation: git syncs knowledge, mothership serves it

**Status:** Specs aligned. Ready for checkpoint commit.


## Session Classification
- Work Type: exploration
- Files Changed:        0
- Commits:        0
- Patterns Modified:        0
- Session Tags: session-20251121-065812-start..session-20251121-065812-end
