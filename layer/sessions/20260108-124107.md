# Session: patina
**ID**: 20260108-124107
**Started**: 2026-01-08T17:41:07Z
**LLM**: claude
**Git Branch**: patina
**Session Tag**: session-20260108-124107-start
**Starting Commit**: 6789346e67e6040498b0df3cfd6a350daca8ed4f

## Previous Session Context
Built `patina report` command using existing scry/assay tools for project state reports. Fixed "why rouille?" semantic search failure by adding commit messages to the semantic index (23 lines in oxidize) - after first building then discarding a 500+ line `distill` command that was over-engineering. Key insight: git commits are the universal truth foundation, sessions enrich but shouldn't duplicate indexed content.

## Goals
- [ ] patina

## Activity Log
### 12:41 - Session Start
Session initialized with goal: patina
Working on branch: patina
Tagged as: session-20260108-124107-start


### 16:54 - Note [patina@6789346e]
Surface architecture clarified: Surface is the patina layer - git-committed, portable, federation interface. Other projects query surface (not eventlog/embeddings). Eventlog is local/rebuildable, embeddings are local ONNX. Surface ties it all together with wikilinks and becomes foundation for future higher-level tools.

### 17:03 - Update (covering since 12:41)

**Git Activity:**
- Commits this session: 0
- Files changed: 1 (spec-surface-layer.md)
- Last commit: 5 hours ago

**Work Completed:**
- Deep design exploration of `layer/surface/` role in patina architecture
- Walked through previous session dump exploring distill/surface ideas
- Researched context compression (LLMLingua, gist tokens, ICAE) for inspiration
- Created and refined `spec-surface-layer.md` with grounded requirements
- Clarified mental model: what's in git vs what's local/rebuildable
- Established surface as the federation interface between projects

**Discussion Context:**
- Started from "why rouille?" problem - led to understanding surface's role
- Explored fancy "typed graph" design from another LLM, then grounded it back to reality
- Traced through eventlog architecture (LiveStore pattern) to understand rebuild flow
- Key question: "how does it help me NOW?" led to clearer value proposition

**Key Decisions:**
1. **Surface is the federation interface** - other projects query surface, not eventlog/embeddings
2. **Obsidian model** - atomic files with wikilinks, no graph database needed
3. **Derived but committed** - surface regenerates from eventlog but lives in git for portability
4. **Simple v1** - no typed edges, no temporal tracking, just atomic markdown + wikilinks
5. **Co-occurrence for links** - same session = related concepts (no embeddings needed for v1)

**Challenges Faced:**
- Got pulled into over-engineering with fancy "typed, temporal, mergeable knowledge graph"
- Grounded back by asking "what problem are we solving?" (bootstrap new projects with past wisdom)
- Clarified eventlog is NOT in git (rebuildable) vs sessions ARE in git (source)

**Patterns Observed:**
1. **Ground fancy ideas in reality** - always ask "what does this actually DO for me?"
2. **Federation is the key value** - surface exists so other projects can query your knowledge
3. **Obsidian model works** - atomic files + wikilinks = graph without infrastructure
4. **LiveStore pays off** - surface is just another materialized view, rebuildable from eventlog


## Session Classification
- Work Type: exploration
- Files Changed:        0
- Commits:        0
- Patterns Modified:        0
- Session Tags: session-20260108-124107-start..session-20260108-124107-end
