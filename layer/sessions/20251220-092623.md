# Session: Begin alignment phases
**ID**: 20251220-092623
**Started**: 2025-12-20T14:26:23Z
**LLM**: claude
**Git Branch**: patina
**Session Tag**: session-20251220-092623-start
**Starting Commit**: f1fe65d13ef98ec1bfc667d100ae94886b83efc7

## Previous Session Context
Last session crystallized the three-stage pipeline architecture: scrape (extract) → oxidize (semantic prep via embeddings) + assay (structural prep via engineered signals) → scry (unified oracle/world model for LLM). Key decisions included making assay the structural prepare stage (parallel to oxidize for semantic), establishing scry as THE unified query interface, and adopting a "signals first, learning later" approach. Next steps identified were implementing `assay derive` subcommand (~150 lines), adding module_signals table to schema, and wiring StructuralOracle into scry.

## Goals
- [ ] Begin alignment phases

## Activity Log
### 09:26 - Session Start
Session initialized with goal: Begin alignment phases
Working on branch: patina
Tagged as: session-20251220-092623-start


### 10:45 - Note [patina@f7399d59]
Phase 1 complete: assay derive computes structural signals (is_used, importer_count, activity_level, centrality). StructuralOracle wired into scry RRF fusion. Signal computation is basic but functional - importer matching and git activity detection can be refined later.

### 11:14 - Update (covering since 09:26)

**Git Activity:**
- Commits this session: 2
- Files changed: 10+ (new oracle, schema updates, CLI additions)
- Last commit: fix(assay): correct signal computation

**Work Completed:**
- Implemented `assay derive` subcommand (~200 lines) - computes structural signals for all modules
- Added `module_signals` table to schema (is_used, importer_count, activity_level, centrality_score, etc.)
- Created `StructuralOracle` in src/retrieval/oracles/structural.rs
- Wired StructuralOracle into QueryEngine alongside semantic, lexical, temporal, persona
- Updated MCP tool descriptions to include "derive" query type
- Fixed signal computation bugs:
  - Importer matching: convert file paths to module paths (./src/adapters/mod.rs → adapters)
  - Git activity: use json_each to search files array instead of LIKE on JSON string
- Created eval/retrieval-queryset.json with 8 ground-truth queries
- Ran git scraper to populate eventlog with git.commit events

**Key Decisions:**
- Structural signals boost via RRF, not independent retrieval (Phase 2/3 for actual fusion logic)
- Path-to-module conversion for import matching: strip ./src/, .rs, /mod, replace / with ::
- Activity levels: high (<=7 days), medium (<=30), low (<=90), dormant (>90 or no commits)
- Degree centrality from call_graph (PageRank deferred to Phase 2)

**Challenges & Solutions:**
- Import matching showed 0 used: realized import_path is `patina::module::name` not file paths → convert paths
- Git activity all dormant: json_extract on $.files returns array, not searchable string → use json_each
- StructuralOracle query model mismatch: currently searches by path LIKE, doesn't boost semantic results → architecture decision to defer fusion boosting

**Lab Baseline Established:**
- MRR: 0.542, Recall@5/10: 42.7%
- 8 queries with ground truth docs

**Patterns Observed:**
- Unix philosophy: assay derive = one job (compute signals), StructuralOracle = one job (expose signals)
- Dual-write pattern: signals stored in table AND returned for display
- json_each for searching JSON arrays in SQLite is powerful but verbose


### 12:26 - Update (covering since 11:14)

**Git Activity:**
- Commits this session: 1
- Files changed: 2 (build.md, spec-robust-signals.md)
- Last commit: docs(signals): add Phase 1.5 robust signals spec

**Work Completed:**
- Ran pre-push checks (all pass)
- Created PR #61 to merge patina → main (merged)
- Synced main with GitHub after merge
- Investigated "unused modules" false negatives
- Discovered: relative imports (`use super::foo`) don't match full module paths
- Developed ML/RL insight about signal design
- Created Phase 1.5 spec for robust signals

**Key Insight (ML/RL framing):**
- We don't need *accurate* features, we need *correlated, robust, cheap* features
- `importer_count` at 60% accuracy is fine - it's a weak signal
- Many weak signals > one accurate signal
- Let Phase 3 learned weights figure out what matters per-repo

**Documentation Added:**
- `layer/core/build.md` - Phase 1.5 section with signal reliability matrix
- `layer/surface/build/spec-robust-signals.md` - Full spec with:
  - Git-based signals (commit_count, contributor_count) ~95% accurate
  - Filename-based signals (is_entry_point, is_test_file) ~99% accurate
  - Composite score formula with placeholder weights
  - Target: MRR 0.60+ (from 0.542), Recall@5 50%+ (from 42.7%)

**Design Principle Crystallized:**
```
Many weak signals > One accurate signal
```


## Session Classification
- Work Type: pattern-work
- Files Changed:       10
- Commits:        3
- Patterns Modified:        2
- Session Tags: session-20251220-092623-start..session-20251220-092623-end
