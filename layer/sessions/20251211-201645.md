# Session: orchestration
**ID**: 20251211-201645
**Started**: 2025-12-12T01:16:45Z
**LLM**: claude
**Git Branch**: patina
**Session Tag**: session-20251211-201645-start
**Starting Commit**: cd11b4e66b2453347c96c4315d41076246fe3b91

## Previous Session Context
Last session was an **exploration of the orchestration agent design**. Key accomplishments: researched prior sessions on agents/MLX/local models, identified 6 pain points with current architecture (stuck at semantic-only, LLM orchestration burden, context limits), and designed the on-device agent architecture using small local LLM (Qwen3-0.6B) with multiple oracles (semantic, temporal, session). Created `layer/surface/concept-orchestration-agent.md` documenting the full concept. Open questions remain: MCP transport (stdio vs Unix socket), which small LLM to use, and whether `scry --deep` should invoke the agent.

## Goals
- [x] Design pivot: Simplify orchestration agent architecture
- [x] Update build.md with Phase 2 tasks
- [x] Create spec-agentic-rag.md
- [x] Implement full Phase 2 agentic RAG system
- [x] Add MCP server with patina_query tool
- [x] Create one-command MCP setup

## Session Summary

**Major accomplishment:** Completed full Phase 2 implementation in a single session. Pivoted from complex local-LLM routing to simple parallel retrieval + RRF fusion. Built and tested MCP server. Created one-command setup for Claude Code integration.

---

## Activity Log

### 20:16 - Session Start
Session initialized with goal: orchestration agent
Working on branch: patina
Tagged as: session-20251211-201645-start

---

### 20:17-20:45 - Design Review & Pivot

**Critical analysis of original concept:**
- Reviewed `layer/surface/concept-orchestration-agent.md`
- Applied ML research lens to small LLM routing assumption

**Problems identified with local LLM routing:**
1. Microsoft research: embedding/keyword routers often outperform small LLM routers
2. 0.6B models can't synthesize well - produce incoherent merges
3. Intent classification (search/explain/suggest) doesn't need ML
4. Model loading overhead (~2GB RAM) buys nothing

**New direction: Parallel Retrieval + RRF Fusion**
- Query all oracles in parallel (semantic, lexical, persona)
- Use Reciprocal Rank Fusion (k=60) to combine ranked lists
- Let frontier LLM synthesize - it's better at this
- No local LLM needed = simpler, more effective

**Key insight:** Research shows parallel retrieval + RRF + frontier synthesis consistently beats small-model routing.

---

### 20:45-21:00 - Documentation Updates

**Created:**
- `layer/surface/build/spec-agentic-rag.md` - Full implementation spec

**Updated:**
- `layer/core/build.md` - Added Phase 2 section with architecture, tasks, validation
- `layer/surface/concept-orchestration-agent.md` - Marked as SUPERSEDED

---

### 21:00-21:15 - Core Principles Audit

Reviewed spec against `layer/core/` principles:

| Principle | Issue Found | Resolution |
|-----------|-------------|------------|
| dependable-rust | Module named "agent" misleading | Renamed to `retrieval/` |
| unix-philosophy | Composition verified | scry → Oracle → QueryEngine → fusion → MCP |
| adapter-pattern | Oracle isn't external system | Documented as "strategy pattern" not adapter |

**Updated spec** with "Alignment with Core Principles" section.

---

### 21:15-21:20 - Progressive Adapters Documentation

User asked about "model alignment without fine-tuning" from prior sessions.

**Found in sessions:** 20251120-110914, 20251121-042111

**Concept:** Progressive Adapters (LoRA-style) - small adapter layers (~1-2M params) on frozen E5-base-v2. NOT fine-tuning.

**Added to build.md Phase 4** with:
- Concept summary
- Six planned dimensions (3 exist, 3 planned)
- Links to architecture doc and sessions

---

### 21:20-21:25 - MCP Design Decision

**Question:** Use official Rust MCP SDK (`rmcp`) or hand-roll?

**Decision:** Hand-roll. Reasons:
- `rmcp` requires async/tokio - Patina uses blocking I/O
- MCP is simple JSON-RPC over stdio (~150 lines)
- Fewer dependencies = fewer breakages
- Aligns with unix-philosophy: simple tools over frameworks

**Updated spec** with "Design: Blocking stdio, No External SDK" section.

---

### 21:25-22:30 - Implementation

#### Oracle Abstraction (src/retrieval/)

**Created files:**
```
src/retrieval/
├── mod.rs              # Public exports
├── oracle.rs           # Oracle trait + OracleResult + OracleMetadata
├── oracles/
│   ├── mod.rs          # Internal exports
│   ├── semantic.rs     # Wraps scry::scry_text()
│   ├── lexical.rs      # Wraps scry::scry_lexical()
│   └── persona.rs      # Wraps persona::query()
├── fusion.rs           # RRF implementation with tests
└── engine.rs           # QueryEngine (parallel dispatch)
```

**Key design decisions:**
- Oracle trait has 3 methods: `name()`, `query()`, `is_available()`
- No mock tests in trait file - test real implementations instead
- Module in binary crate (not lib) because it needs `commands::scry`

**RRF Fusion:**
- k=60 (standard from Cormack et al. paper)
- Over-fetch 2x from each oracle for better fusion
- 3 unit tests all passing

#### MCP Server (src/mcp/)

**Created files:**
```
src/mcp/
├── mod.rs              # Public: run_mcp_server()
├── protocol.rs         # Request, Response, Error types
└── server.rs           # stdio transport + tool handlers
```

**MCP Methods implemented:**
- `initialize` - Returns capabilities and server info
- `initialized` - Acknowledges initialization
- `tools/list` - Returns patina_query tool schema
- `tools/call` - Dispatches to QueryEngine

**Tool defined:**
```json
{
  "name": "patina_query",
  "description": "Search codebase knowledge using hybrid retrieval...",
  "inputSchema": {
    "properties": {
      "query": { "type": "string" },
      "limit": { "type": "integer", "default": 10 }
    },
    "required": ["query"]
  }
}
```

#### CLI Integration

**Added to main.rs:**
- `mod mcp;` - MCP module
- `--mcp` flag on `serve` command

**Testing:**
```bash
# Initialize
echo '{"jsonrpc":"2.0","id":1,"method":"initialize"}' | patina serve --mcp
# Returns: capabilities, protocolVersion, serverInfo

# List tools
echo '{"jsonrpc":"2.0","id":2,"method":"tools/list"}' | patina serve --mcp
# Returns: patina_query tool

# Query
echo '{"jsonrpc":"2.0","id":3,"method":"tools/call","params":{"name":"patina_query","arguments":{"query":"error handling"}}}' | patina serve --mcp
# Returns: fused results from semantic + lexical + persona
```

---

### 22:30-23:00 - MCP Setup Automation

**Question:** How to set up MCP on clean computers? Walkthrough for upgrades?

**Research:** Web search found Claude Code has built-in CLI:
```bash
claude mcp add --transport stdio patina -- patina serve --mcp
```

**Implemented:** `patina adapter mcp claude`

**Code added to `src/commands/adapter.rs`:**
- New `Mcp` subcommand with `--remove` flag
- `configure_mcp()` function that shells out to `claude mcp add/remove`
- Uses `std::env::current_exe()` to find patina binary path

**Testing:**
```bash
$ patina adapter mcp claude
Adding patina MCP server to Claude Code...
✓ Added patina MCP server

  Restart Claude Code to use patina_query tool.
  Verify with: claude mcp list

$ claude mcp list
patina: /Users/nicabar/.cargo/bin/patina serve --mcp - ✓ Connected
```

---

## Files Created/Modified

### Created
| File | Purpose |
|------|---------|
| `layer/surface/build/spec-agentic-rag.md` | Full Phase 2 spec |
| `src/retrieval/mod.rs` | Module exports |
| `src/retrieval/oracle.rs` | Oracle trait + types |
| `src/retrieval/oracles/mod.rs` | Oracle implementations export |
| `src/retrieval/oracles/semantic.rs` | E5 + USearch oracle |
| `src/retrieval/oracles/lexical.rs` | BM25/FTS5 oracle |
| `src/retrieval/oracles/persona.rs` | Persona oracle |
| `src/retrieval/fusion.rs` | RRF fusion + tests |
| `src/retrieval/engine.rs` | QueryEngine |
| `src/mcp/mod.rs` | MCP module exports |
| `src/mcp/protocol.rs` | JSON-RPC types |
| `src/mcp/server.rs` | stdio server |

### Modified
| File | Change |
|------|--------|
| `layer/core/build.md` | Added Phase 2 + Phase 4 sections |
| `layer/surface/concept-orchestration-agent.md` | Marked SUPERSEDED |
| `src/main.rs` | Added `mod mcp`, `mod retrieval`, `--mcp` flag |
| `src/commands/adapter.rs` | Added `Mcp` subcommand |

---

## Key Insights

1. **Simple beats complex:** Parallel retrieval + RRF + frontier synthesis outperforms local LLM routing with less code and no model dependencies.

2. **Use platform tools:** Claude's `claude mcp add` CLI is simpler than manually editing JSON config files.

3. **Strategy vs Adapter:** Oracle trait is a strategy pattern (internal), not adapter pattern (external systems). Important distinction for documentation.

4. **Blocking is fine:** MCP over stdio doesn't need async. ~150 lines of synchronous code works perfectly.

5. **Binary vs Library crate:** `retrieval/` lives in binary crate because it needs `commands::scry`. Could refactor later if needed.

---

## Walkthrough Documentation

### Clean Install
```bash
cargo install patina
cd my-project
patina init . --llm=claude
patina scrape && patina oxidize
patina adapter mcp claude
# Restart Claude Code
```

### Upgrade Existing
```bash
cargo install patina --force
claude mcp list  # Check if patina listed
patina adapter mcp claude  # If not listed
```

### Remove MCP
```bash
patina adapter mcp claude --remove
```

---

## Next Steps

1. **Test in real usage** - Use patina_query in Claude Code sessions
2. **Add more tools** - patina_context, patina_session_*
3. **Optimize latency** - Profile and tune if >500ms
4. **Phase 3** - Session → persona distillation automation

---

## Session Stats

- **Duration:** ~3 hours
- **Files created:** 12
- **Files modified:** 4
- **Tests added:** 3 (RRF fusion)
- **Lines of code:** ~500 new
- **Phase 2 status:** COMPLETE

## Session Classification
- Work Type: exploration
- Files Changed:        0
- Commits:        0
- Patterns Modified:        0
- Session Tags: session-20251211-201645-start..session-20251211-201645-end
