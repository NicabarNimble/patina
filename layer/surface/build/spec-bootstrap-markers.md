---
id: spec-bootstrap-markers
status: active
created: 2026-01-20
tags: [spec, adapter, bootstrap, fix]
references: [unix-philosophy, dependable-rust]
---

# Spec: Bootstrap File Marker-Based Updates

**Problem**: `patina adapter refresh` overwrites entire CLAUDE.md/GEMINI.md, destroying user content.

**Solution**: Only modify content between `<!-- PATINA:START -->` and `<!-- PATINA:END -->` markers.

---

## Core Values Alignment

| Core Value | Application |
|------------|-------------|
| **Unix Philosophy** | One job: update Patina section. Simple string ops, no regex. |
| **Dependable Rust** | Keep interface stable (`generate_bootstrap(name, path)`), change implementation only. |

---

## Behavior

| Bootstrap State | Action |
|-----------------|--------|
| Doesn't exist | Create with Patina section |
| Exists, no markers | Append section at end |
| Exists, has markers | Replace content between markers only |

**User content outside markers is never touched.**

---

## Implementation

Simple string find/replace - no regex needed:

```rust
const MARKER_START: &str = "<!-- PATINA:START -->";
const MARKER_END: &str = "<!-- PATINA:END -->";

/// Update Patina section in bootstrap file (marker-based, preserves user content)
pub fn generate_bootstrap(name: &str, project_path: &Path) -> Result<()> {
    let adapter = Adapter::from_name(name)
        .ok_or_else(|| anyhow::anyhow!("Unknown adapter: {}", name))?;

    let bootstrap_path = project_path.join(adapter.bootstrap_file());
    let section = patina_section(&adapter);

    let new_content = if bootstrap_path.exists() {
        let content = fs::read_to_string(&bootstrap_path)?;
        update_or_append_section(&content, &section)
    } else {
        section
    };

    fs::write(&bootstrap_path, new_content)?;
    Ok(())
}

fn update_or_append_section(content: &str, section: &str) -> String {
    if let (Some(start), Some(end)) = (content.find(MARKER_START), content.find(MARKER_END)) {
        if start < end {
            // Replace between markers
            let before = &content[..start];
            let after = &content[end + MARKER_END.len()..];
            return format!("{}{}{}", before, section, after);
        }
    }
    // Append (no markers or malformed)
    format!("{}\n\n{}", content.trim_end(), section)
}

fn patina_section(adapter: &Adapter) -> String {
    format!(
        r#"<!-- PATINA:START -->
## Patina

MCP tools: `scry` (search), `context` (patterns)

*Generated by Patina | Adapter: {}*
<!-- PATINA:END -->"#,
        adapter.display()
    )
}
```

---

## Checklist

- [ ] Update `generate_bootstrap()` in `src/adapters/launch.rs`
- [ ] Add `update_or_append_section()` helper
- [ ] Add `patina_section()` helper
- [ ] Add constants `MARKER_START`, `MARKER_END`
- [ ] Test: create new bootstrap
- [ ] Test: append to existing (no markers)
- [ ] Test: replace existing section (has markers)
